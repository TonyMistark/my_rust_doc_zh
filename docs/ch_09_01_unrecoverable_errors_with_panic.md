### 使用`panic!`处理不可恢复错误

有时，你的代码里会发生bug，并且你什么也做不了。在这种情况，Rust有`panic!`宏。在实践中有两种方式会导致panic：通过采取导致代码panic的操作(例如访问超出末尾的数组)通过显式调用`panic!`宏。默认情况下，panic会打印一个失败的信息，展开并清理栈数据，然后退出。通过一个环境变量，你也可以让 Rust 在 panic 发生时打印调用堆栈（call stack）以便于定位 panic 的原因。

> #### 对应panic时的栈展开或终止
>
> 当出现panic时，程序默认会**展开**(unwinding)，这意味着Rust会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另外一种选择是直接**终止**(abort)，这会不清理数据就退出程序。
>
> 那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic时通过`Cargo.toml`的`[profile]`部分增加`panic = 'abort'`，可以由展开切换为终止。例如，如果你想在release模式中panic时终止：
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

让我们在一个简单的程序中调用`panic!`:

src/main.rs

```rust
fn main() {
    panic!("crash and burn");
}
```

当你运行这个程序，你会看到如下的错误：

```rust
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

调用`panic!`导致错误在最后两行进行了详细说明。第一行展示了panic的信息并告诉我们错误代码的地址在:`src/main.rs:2:5`，意思是在`src/main.rs`这个文件的第2行，第5个字符。

这个示例中，错误信息是发生在我们自己编写的代码中，我们在对应的位置就能找到`panic!`调用。在另外的一些情况中，`panic!`有可能出现在我们调用的代码中。错误信息报告的文件和行号可能指向别人代码中的`panic!`调用，而不是我们代码中最终导致`panic!`的那一行。我们可以使用`panic!`被调用的函数的backtrace来寻找代码中出问题的地方。下面我们来详细介绍backtrace是什么。

#### 使用`panic!`的backtrace

让我们来看看另外一个例子，当因为我们自己的代码有bug而导致库函数调用`panic!`是什么样的。如Listing 9-1所示的代码尝试访问超出范围的vector的索引。

Filename: src/main.rs

```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

Listing 9-1: Attempting to access an element beyond the end of a vector, which will cause a call to `panic!`

这里，我们尝试去访问第100个元素(索引99就是第100个元素，索引是从0开始的)，但是vector只有3个元素，肯定会报错。在这个场景中，Rust就会panic。使用`[]`就是企图返回一个元素，但是你传入一个无效的索引，又不会有这个元素，Rust就肯定不会返回正确的结果。

在C语言中，尝试读取数据结构之后的值是未定义行为(undefined behavior)。你可能会得到一个这个位置的对应的值，但是这个可能是任何的值，但就不是你想要访问的值，因为这个位置的值不属于你想要访问的数据结构范围的值。这个被叫做**缓冲区溢出(buffer overread)**，并且可能会导致安全漏洞，比如攻击者可以像这样操作索引来读取存储在数据结构之后不被允许访问的数据。

为了防止这种漏洞，如果尝试读取一个索引不存在的元素，Rust会停止执行并拒绝继续。尝试运行上面的程序会出现如下的错误：

```rust
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

上面的错误信息指出错误发生在`src/main.rs`文件的第4行第5个字符，我们尝试访问索引为99的元素。接着一行的信息告诉我们可以设置`RUST_BACKTRACE`环境变量来获取backtrace查看发生了什么错误。一个backtrace是一个已经被调用直到当前这一个点的所有的函数列表。Backtrace在Rust的工作原理和其他语言一样：阅读backtrace的关键是从头开始读一直到发现你编写的代码；往下则是你调用的代码。这些行可能包含核心Rust代码，标准库代码或用到的crate代码。让我们设置`RUST_BACKTRACE`环境变量在Listing 9-2中看看都输出了些什么：

```rust
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

Listing 9-2: The backtrace generated by a `panic!`displayed when the environment variable `RUST_BACKTRACE`is set

真是输出了一大坨啊！操作系统不同，Rust版本不同，你看到的输出可能会有所不同。为了使用这些信息进行回溯，必须启用debug模式。默认就是debug模式，只要在`cargo build`或者`cargo run`之后不要加`--release`参数。

在Listing 9-2的第6行的backtrace指出了我们项目造成的问题：`src/main.rs`的第4行。如果我们不想我们的程序panic，我们就应该开始检查定位到第一行我们自己写的代码。在Listing 9-1中，我们故意写了造成panic的代码，修复这个panic就是不要去访问超出vector范围的索引。当你的代码在将来panic， 你需要弄清楚代码使用什么数据做了什么样的操作，以及正确情况下代码应该做什么。

本章后面的小节 ["To `panic!` Or not to `panic!`"](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic) 部分讲回`panic!`，详细讲解应该或者不应该用`panic!`来处理错误情况。接下来一节我们来讲解如何使用`Result`恢复一个错误。

